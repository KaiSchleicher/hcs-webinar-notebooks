#
# Copyright (C) 2016 Glencoe Software, Inc.
# All Rights Reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


import numpy as np


def get_plate_layout(conn, plate_id):
    '''
    Build the plate grid from a Plate.
    '''
    # Request plate object.
    plate = conn.getObject("Plate", plate_id)
    # We'll use Plate's Well Grid to map Image Id
    # to a particular Row-Column Cell.
    wg = plate.getWellGrid()
    plate_layout = {}
    # Loop over all Rows and Columns and map the ImageIds.
    # For multiple fields this methods would have to be slightly modified.
    for x, row in enumerate(wg):
        for y, column in enumerate(row):
            image_id = column.getWellSample().getImage().getId()
            plate_layout[image_id] = [x, y]
    plate_layout["number_of_rows"] = len(wg)
    plate_layout["number_of_columns"] = len(wg[0])
    return plate_layout


def build_display_matrix(plate_layout, image_id_column, property_to_display):
    '''
    Use the plate_layout generated by get_plate_layout() to create
    a numpy array for display.
    Create a numpy array with correct number of rows and columns.
    Using Image Ids map Values to correct matrix elements.
    '''
    array = np.zeros(
        [plate_layout["number_of_rows"],
         plate_layout["number_of_columns"]])
    for index, image_id in enumerate(image_id_column):
        x, y = plate_layout[image_id]
        array[x][y] = property_to_display[index]
    return array


def set_axis_properties(axis):
    '''
    Axis properties for plate grid display.
    '''
    xlabels = range(1, 13)
    ylabels = 'ABCDEFGH'
    axis.xaxis.set(ticks=np.arange(0.5, len(xlabels)), ticklabels=xlabels)
    axis.yaxis.set(ticks=np.arange(0.5, len(ylabels)), ticklabels=ylabels)
    axis.set_ylim(axis.get_ylim()[::-1])
    axis.xaxis.tick_top()


def set_axis_properties_pca(axis, x_labels, y_labels):
    '''
    Axis properties for Principla Component Analysis results.
    '''
    xlabels = x_labels
    ylabels = y_labels
    axis.xaxis.set(ticks=np.arange(0.5, len(xlabels)), ticklabels=xlabels)
    axis.yaxis.set(ticks=np.arange(0.5, len(ylabels)), ticklabels=ylabels)
    axis.set_ylim(axis.get_ylim()[::-1])
    axis.xaxis.tick_top()


def get_index_list(header, columns, black_list=[]):
    '''
    Header filter. Used in examples to remove non analytical data.
    '''
    header_index = []
    mark_to_delete = []
    for column in columns:
        if column in black_list:
            mark_to_delete.append(column)
        elif column not in header:
            mark_to_delete.append(column)
        else:
            header_index.append(header.index(column))
    for column in mark_to_delete:
        columns.remove(column)
    return header_index


def get_data_from_a_line_by_index(line, index):
    '''
    Row filter. Get data only for the cells given by index.
    '''
    data = []
    for i in index:
        data.append(line[i])
    return data


def read_and_filter(file_path, columns_to_retrieve):
    '''
    Read in data from a file for specific columns.
    file_path - path on the disk to a Comma Separated Value (CSV) file.
    columns_to_retrive - list of column names to read in.
    '''
    cols = list(columns_to_retrieve)
    data = []
    with open(file_path) as file_to_read:
        counter = 0
        header_index = None
        while True:
            line = file_to_read.readline().strip().split(',')
            if len(line) == 1:
                break
            if not counter:
                # Get index of columns to read in.
                header_index = get_index_list(line, cols)
                data.append(cols)
                counter += 1
                continue
            if header_index is None:
                print "Header is None"
                break
            # Read data from each row only for columns_to_retrieve.
            data.append(get_data_from_a_line_by_index(line, header_index))
            counter += 1
    return data


def add_labels(plt, names, X, Y):
    '''
    Add labels to points on PCA plot.
    names - labels to assign to points.
    X, Y - points coordinates.
    '''
    for label, x, y in zip(names, X, Y):
        plt.annotate(
            label,
            xy=(x, y),
            xytext=(-10, 25),
            textcoords='offset points',
            ha='right', va='bottom',
            arrowprops=dict(arrowstyle='->', connectionstyle='arc3, rad=0'))
